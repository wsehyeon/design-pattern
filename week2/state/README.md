## State pattern
### divide and conquer  
- 상태가 많아질수록 조건 분기가 늘어남.
- 상태를 클래스로 표현하면, 상태의 추가 및 관리가 수월해짐  
(서브젝트 기준, 레벨이 늘어나더라도 플레이어는 영향을 받지 않는다.)

### 상태의 변경은 어디서 이루어져아 할까?
1. practice처럼 구체화된 상태 클레스테서 변경하는 방식  
	- `다른상태로 변경하는 때`가 구체화된 클래스 내에 구현되어있음
	- 주간모드에서 다른 단계로 언제변경하는지 궁금하면 주간 클래스를 확인하면 된다.
	- 구체화된 상태 클래스들이 자신과 다른 상태 클래스들을 알고 있어야 함. 주간모드가 삭제된다면, 야간모드 클래스에서도 수정이 필요하다. (변경하는 분기점 수정)  
	
2. Context 단에서 변경하는 경우  
	- 구체화된 상태 클래스들 간에 독립성이 높아지지만, 모든 상태 클래스들을 Context가 모든 상태 클래스들을 알아야 한다.
	(분기점 설정시 모든 상태들을 알고 있어야 하기 떄문)
	- Mediator 패턴을 적용할 수 있을지도? (배우고 돌아오기)  


<br>

```
Level 기초클래스에서 go() 처럼 구현하는 경우

- 조건문(분기점)을 level에서 관리하도록 go()를 통해서 레벨 객체를 받아 레벨을 변경. 플레이어는 구체화된 레벨들을 알 필요가 없어졌음

- 이걸 요구한게 맞는진 모르겠지만, 플레이어가 구체적인 레벨을 알 필요가 없는게 낫다고 생각하면서 구현함

p1.upgradeLevel(p1.getLevel().go(2));  
메인문에서 레벨을 변경하려면 레벨 인스턴스를 불러온다음에 go 메소드를 호출...
```